/**
 * This file was automatically generated by @cosmwasm/ts-codegen@1.12.1.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */
import { CosmWasmClient, SigningCosmWasmClient, type ExecuteResult } from '@cosmjs/cosmwasm-stargate';
import type { StdFee } from '@cosmjs/amino';
import type { Timestamp, Binary, Uint128, Decimal, TokenInfoProviderInstantiateMsg, CollectionInfo, TrancheInfo, Expiration, LockTokensProof, ProposalToLockups, Coin, AllNftInfoResponse, OwnerOfResponse, NftInfoResponse, OperatorsResponse, TokensResponse, AllUserLockupsResponse, AllUserLockupsWithTrancheInfosResponse, AllVotesResponse, AllVotesRoundTrancheResponse, ApprovalResponse, ApprovalsResponse, CanLockDenomResponse, ConstantsResponse, CurrentRoundResponse, ExpiredUserLockupsResponse, GatekeeperResponse, ICQManagersResponse, LiquidityDeploymentResponse, LockVotesHistoryResponse, LockupsSharesResponse, NumTokensResponse, ProposalResponse, RegisteredValidatorQueriesResponse, RoundEndResponse, RoundProposalsResponse, RoundTotalVotingPowerResponse, RoundTrancheLiquidityDeploymentsResponse, SpecificUserLockupsResponse, SpecificUserLockupsWithTrancheInfosResponse, TokenInfoProvidersResponse, TopNProposalsResponse, TotalLockedTokensResponse, TotalPowerAtHeightResponse, TranchesResponse, UserVotedLocksResponse, UserVotesResponse, UserVotingPowerResponse, VotingPowerAtHeightResponse, WhitelistResponse, WhitelistAdminsResponse } from './HydroBase.types';
export interface HydroBaseReadOnlyInterface {
    contractAddress: string;
    constants: () => Promise<ConstantsResponse>;
    tokenInfoProviders: () => Promise<TokenInfoProvidersResponse>;
    gatekeeper: () => Promise<GatekeeperResponse>;
    tranches: () => Promise<TranchesResponse>;
    allUserLockups: ({ address, limit, startFrom }: {
        address: string;
        limit: number;
        startFrom: number;
    }) => Promise<AllUserLockupsResponse>;
    specificUserLockups: ({ address, lockIds }: {
        address: string;
        lockIds: number[];
    }) => Promise<SpecificUserLockupsResponse>;
    allUserLockupsWithTrancheInfos: ({ address, limit, startFrom }: {
        address: string;
        limit: number;
        startFrom: number;
    }) => Promise<AllUserLockupsWithTrancheInfosResponse>;
    specificUserLockupsWithTrancheInfos: ({ address, lockIds }: {
        address: string;
        lockIds: number[];
    }) => Promise<SpecificUserLockupsWithTrancheInfosResponse>;
    expiredUserLockups: ({ address, limit, startFrom }: {
        address: string;
        limit: number;
        startFrom: number;
    }) => Promise<ExpiredUserLockupsResponse>;
    userVotingPower: ({ address }: {
        address: string;
    }) => Promise<UserVotingPowerResponse>;
    userVotes: ({ address, roundId, trancheId }: {
        address: string;
        roundId: number;
        trancheId: number;
    }) => Promise<UserVotesResponse>;
    userVotedLocks: ({ proposalId, roundId, trancheId, userAddress }: {
        proposalId?: number;
        roundId: number;
        trancheId: number;
        userAddress: string;
    }) => Promise<UserVotedLocksResponse>;
    lockVotesHistory: ({ lockId, startFromRoundId, stopAtRoundId, trancheId }: {
        lockId: number;
        startFromRoundId?: number;
        stopAtRoundId?: number;
        trancheId?: number;
    }) => Promise<LockVotesHistoryResponse>;
    allVotes: ({ limit, startFrom }: {
        limit: number;
        startFrom: number;
    }) => Promise<AllVotesResponse>;
    allVotesRoundTranche: ({ limit, roundId, startFrom, trancheId }: {
        limit: number;
        roundId: number;
        startFrom: number;
        trancheId: number;
    }) => Promise<AllVotesRoundTrancheResponse>;
    currentRound: () => Promise<CurrentRoundResponse>;
    roundEnd: ({ roundId }: {
        roundId: number;
    }) => Promise<RoundEndResponse>;
    roundTotalVotingPower: ({ roundId }: {
        roundId: number;
    }) => Promise<RoundTotalVotingPowerResponse>;
    roundProposals: ({ limit, roundId, startFrom, trancheId }: {
        limit: number;
        roundId: number;
        startFrom: number;
        trancheId: number;
    }) => Promise<RoundProposalsResponse>;
    proposal: ({ proposalId, roundId, trancheId }: {
        proposalId: number;
        roundId: number;
        trancheId: number;
    }) => Promise<ProposalResponse>;
    topNProposals: ({ numberOfProposals, roundId, trancheId }: {
        numberOfProposals: number;
        roundId: number;
        trancheId: number;
    }) => Promise<TopNProposalsResponse>;
    whitelist: () => Promise<WhitelistResponse>;
    whitelistAdmins: () => Promise<WhitelistAdminsResponse>;
    iCQManagers: () => Promise<ICQManagersResponse>;
    totalLockedTokens: () => Promise<TotalLockedTokensResponse>;
    registeredValidatorQueries: () => Promise<RegisteredValidatorQueriesResponse>;
    canLockDenom: ({ tokenDenom }: {
        tokenDenom: string;
    }) => Promise<CanLockDenomResponse>;
    liquidityDeployment: ({ proposalId, roundId, trancheId }: {
        proposalId: number;
        roundId: number;
        trancheId: number;
    }) => Promise<LiquidityDeploymentResponse>;
    roundTrancheLiquidityDeployments: ({ limit, roundId, startFrom, trancheId }: {
        limit: number;
        roundId: number;
        startFrom: number;
        trancheId: number;
    }) => Promise<RoundTrancheLiquidityDeploymentsResponse>;
    totalPowerAtHeight: ({ height }: {
        height?: number;
    }) => Promise<TotalPowerAtHeightResponse>;
    votingPowerAtHeight: ({ address, height }: {
        address: string;
        height?: number;
    }) => Promise<VotingPowerAtHeightResponse>;
    ownerOf: ({ includeExpired, tokenId }: {
        includeExpired?: boolean;
        tokenId: string;
    }) => Promise<OwnerOfResponse>;
    approval: ({ includeExpired, spender, tokenId }: {
        includeExpired?: boolean;
        spender: string;
        tokenId: string;
    }) => Promise<ApprovalResponse>;
    approvals: ({ includeExpired, tokenId }: {
        includeExpired?: boolean;
        tokenId: string;
    }) => Promise<ApprovalsResponse>;
    allOperators: ({ includeExpired, limit, owner, startAfter }: {
        includeExpired?: boolean;
        limit?: number;
        owner: string;
        startAfter?: string;
    }) => Promise<OperatorsResponse>;
    numTokens: () => Promise<NumTokensResponse>;
    collectionInfo: () => Promise<CollectionInfo>;
    nftInfo: ({ tokenId }: {
        tokenId: string;
    }) => Promise<NftInfoResponse>;
    allNftInfo: ({ includeExpired, tokenId }: {
        includeExpired?: boolean;
        tokenId: string;
    }) => Promise<AllNftInfoResponse>;
    tokens: ({ limit, owner, startAfter }: {
        limit?: number;
        owner: string;
        startAfter?: string;
    }) => Promise<TokensResponse>;
    allTokens: ({ limit, startAfter }: {
        limit?: number;
        startAfter?: string;
    }) => Promise<TokensResponse>;
    lockupsShares: ({ lockIds }: {
        lockIds: number[];
    }) => Promise<LockupsSharesResponse>;
}
export declare class HydroBaseQueryClient implements HydroBaseReadOnlyInterface {
    client: CosmWasmClient;
    contractAddress: string;
    constructor(client: CosmWasmClient, contractAddress: string);
    constants: () => Promise<ConstantsResponse>;
    tokenInfoProviders: () => Promise<TokenInfoProvidersResponse>;
    gatekeeper: () => Promise<GatekeeperResponse>;
    tranches: () => Promise<TranchesResponse>;
    allUserLockups: ({ address, limit, startFrom }: {
        address: string;
        limit: number;
        startFrom: number;
    }) => Promise<AllUserLockupsResponse>;
    specificUserLockups: ({ address, lockIds }: {
        address: string;
        lockIds: number[];
    }) => Promise<SpecificUserLockupsResponse>;
    allUserLockupsWithTrancheInfos: ({ address, limit, startFrom }: {
        address: string;
        limit: number;
        startFrom: number;
    }) => Promise<AllUserLockupsWithTrancheInfosResponse>;
    specificUserLockupsWithTrancheInfos: ({ address, lockIds }: {
        address: string;
        lockIds: number[];
    }) => Promise<SpecificUserLockupsWithTrancheInfosResponse>;
    expiredUserLockups: ({ address, limit, startFrom }: {
        address: string;
        limit: number;
        startFrom: number;
    }) => Promise<ExpiredUserLockupsResponse>;
    userVotingPower: ({ address }: {
        address: string;
    }) => Promise<UserVotingPowerResponse>;
    userVotes: ({ address, roundId, trancheId }: {
        address: string;
        roundId: number;
        trancheId: number;
    }) => Promise<UserVotesResponse>;
    userVotedLocks: ({ proposalId, roundId, trancheId, userAddress }: {
        proposalId?: number;
        roundId: number;
        trancheId: number;
        userAddress: string;
    }) => Promise<UserVotedLocksResponse>;
    lockVotesHistory: ({ lockId, startFromRoundId, stopAtRoundId, trancheId }: {
        lockId: number;
        startFromRoundId?: number;
        stopAtRoundId?: number;
        trancheId?: number;
    }) => Promise<LockVotesHistoryResponse>;
    allVotes: ({ limit, startFrom }: {
        limit: number;
        startFrom: number;
    }) => Promise<AllVotesResponse>;
    allVotesRoundTranche: ({ limit, roundId, startFrom, trancheId }: {
        limit: number;
        roundId: number;
        startFrom: number;
        trancheId: number;
    }) => Promise<AllVotesRoundTrancheResponse>;
    currentRound: () => Promise<CurrentRoundResponse>;
    roundEnd: ({ roundId }: {
        roundId: number;
    }) => Promise<RoundEndResponse>;
    roundTotalVotingPower: ({ roundId }: {
        roundId: number;
    }) => Promise<RoundTotalVotingPowerResponse>;
    roundProposals: ({ limit, roundId, startFrom, trancheId }: {
        limit: number;
        roundId: number;
        startFrom: number;
        trancheId: number;
    }) => Promise<RoundProposalsResponse>;
    proposal: ({ proposalId, roundId, trancheId }: {
        proposalId: number;
        roundId: number;
        trancheId: number;
    }) => Promise<ProposalResponse>;
    topNProposals: ({ numberOfProposals, roundId, trancheId }: {
        numberOfProposals: number;
        roundId: number;
        trancheId: number;
    }) => Promise<TopNProposalsResponse>;
    whitelist: () => Promise<WhitelistResponse>;
    whitelistAdmins: () => Promise<WhitelistAdminsResponse>;
    iCQManagers: () => Promise<ICQManagersResponse>;
    totalLockedTokens: () => Promise<TotalLockedTokensResponse>;
    registeredValidatorQueries: () => Promise<RegisteredValidatorQueriesResponse>;
    canLockDenom: ({ tokenDenom }: {
        tokenDenom: string;
    }) => Promise<CanLockDenomResponse>;
    liquidityDeployment: ({ proposalId, roundId, trancheId }: {
        proposalId: number;
        roundId: number;
        trancheId: number;
    }) => Promise<LiquidityDeploymentResponse>;
    roundTrancheLiquidityDeployments: ({ limit, roundId, startFrom, trancheId }: {
        limit: number;
        roundId: number;
        startFrom: number;
        trancheId: number;
    }) => Promise<RoundTrancheLiquidityDeploymentsResponse>;
    totalPowerAtHeight: ({ height }: {
        height?: number;
    }) => Promise<TotalPowerAtHeightResponse>;
    votingPowerAtHeight: ({ address, height }: {
        address: string;
        height?: number;
    }) => Promise<VotingPowerAtHeightResponse>;
    ownerOf: ({ includeExpired, tokenId }: {
        includeExpired?: boolean;
        tokenId: string;
    }) => Promise<OwnerOfResponse>;
    approval: ({ includeExpired, spender, tokenId }: {
        includeExpired?: boolean;
        spender: string;
        tokenId: string;
    }) => Promise<ApprovalResponse>;
    approvals: ({ includeExpired, tokenId }: {
        includeExpired?: boolean;
        tokenId: string;
    }) => Promise<ApprovalsResponse>;
    allOperators: ({ includeExpired, limit, owner, startAfter }: {
        includeExpired?: boolean;
        limit?: number;
        owner: string;
        startAfter?: string;
    }) => Promise<OperatorsResponse>;
    numTokens: () => Promise<NumTokensResponse>;
    collectionInfo: () => Promise<CollectionInfo>;
    nftInfo: ({ tokenId }: {
        tokenId: string;
    }) => Promise<NftInfoResponse>;
    allNftInfo: ({ includeExpired, tokenId }: {
        includeExpired?: boolean;
        tokenId: string;
    }) => Promise<AllNftInfoResponse>;
    tokens: ({ limit, owner, startAfter }: {
        limit?: number;
        owner: string;
        startAfter?: string;
    }) => Promise<TokensResponse>;
    allTokens: ({ limit, startAfter }: {
        limit?: number;
        startAfter?: string;
    }) => Promise<TokensResponse>;
    lockupsShares: ({ lockIds }: {
        lockIds: number[];
    }) => Promise<LockupsSharesResponse>;
}
export interface HydroBaseInterface extends HydroBaseReadOnlyInterface {
    contractAddress: string;
    sender: string;
    lockTokens: ({ lockDuration, proof }: {
        lockDuration: number;
        proof?: LockTokensProof;
    }, fee_?: number | StdFee | 'auto', memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    refreshLockDuration: ({ lockDuration, lockIds }: {
        lockDuration: number;
        lockIds: number[];
    }, fee_?: number | StdFee | 'auto', memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    unlockTokens: ({ lockIds }: {
        lockIds?: number[];
    }, fee_?: number | StdFee | 'auto', memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    createProposal: ({ deploymentDuration, description, minimumAtomLiquidityRequest, roundId, title, trancheId }: {
        deploymentDuration: number;
        description: string;
        minimumAtomLiquidityRequest: Uint128;
        roundId?: number;
        title: string;
        trancheId: number;
    }, fee_?: number | StdFee | 'auto', memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    vote: ({ proposalsVotes, trancheId }: {
        proposalsVotes: ProposalToLockups[];
        trancheId: number;
    }, fee_?: number | StdFee | 'auto', memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    unvote: ({ lockIds, trancheId }: {
        lockIds: number[];
        trancheId: number;
    }, fee_?: number | StdFee | 'auto', memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    addAccountToWhitelist: ({ address }: {
        address: string;
    }, fee_?: number | StdFee | 'auto', memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    removeAccountFromWhitelist: ({ address }: {
        address: string;
    }, fee_?: number | StdFee | 'auto', memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    updateConfig: ({ activateAt, cw721CollectionInfo, knownUsersCap, maxDeploymentDuration, maxLockedTokens }: {
        activateAt: Timestamp;
        cw721CollectionInfo?: CollectionInfo;
        knownUsersCap?: number;
        maxDeploymentDuration?: number;
        maxLockedTokens?: number;
    }, fee_?: number | StdFee | 'auto', memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    deleteConfigs: ({ timestamps }: {
        timestamps: Timestamp[];
    }, fee_?: number | StdFee | 'auto', memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    pause: (fee_?: number | StdFee | 'auto', memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    addTranche: ({ tranche }: {
        tranche: TrancheInfo;
    }, fee_?: number | StdFee | 'auto', memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    editTranche: ({ trancheId, trancheMetadata, trancheName }: {
        trancheId: number;
        trancheMetadata?: string;
        trancheName?: string;
    }, fee_?: number | StdFee | 'auto', memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    createIcqsForValidators: ({ validators }: {
        validators: string[];
    }, fee_?: number | StdFee | 'auto', memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    addICQManager: ({ address }: {
        address: string;
    }, fee_?: number | StdFee | 'auto', memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    removeICQManager: ({ address }: {
        address: string;
    }, fee_?: number | StdFee | 'auto', memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    withdrawICQFunds: ({ amount }: {
        amount: Uint128;
    }, fee_?: number | StdFee | 'auto', memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    addLiquidityDeployment: ({ deployedFunds, destinations, fundsBeforeDeployment, proposalId, remainingRounds, roundId, totalRounds, trancheId }: {
        deployedFunds: Coin[];
        destinations: string[];
        fundsBeforeDeployment: Coin[];
        proposalId: number;
        remainingRounds: number;
        roundId: number;
        totalRounds: number;
        trancheId: number;
    }, fee_?: number | StdFee | 'auto', memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    removeLiquidityDeployment: ({ proposalId, roundId, trancheId }: {
        proposalId: number;
        roundId: number;
        trancheId: number;
    }, fee_?: number | StdFee | 'auto', memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    updateTokenGroupRatio: ({ newRatio, oldRatio, tokenGroupId }: {
        newRatio: Decimal;
        oldRatio: Decimal;
        tokenGroupId: string;
    }, fee_?: number | StdFee | 'auto', memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    addTokenInfoProvider: ({ tokenInfoProvider }: {
        tokenInfoProvider: TokenInfoProviderInstantiateMsg;
    }, fee_?: number | StdFee | 'auto', memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    removeTokenInfoProvider: ({ providerId }: {
        providerId: string;
    }, fee_?: number | StdFee | 'auto', memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    setGatekeeper: ({ gatekeeperAddr }: {
        gatekeeperAddr?: string;
    }, fee_?: number | StdFee | 'auto', memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    transferNft: ({ recipient, tokenId }: {
        recipient: string;
        tokenId: string;
    }, fee_?: number | StdFee | 'auto', memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    sendNft: ({ contract, msg, tokenId }: {
        contract: string;
        msg: Binary;
        tokenId: string;
    }, fee_?: number | StdFee | 'auto', memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    lockTokensThenSendNft: ({ contract, lockDuration, msg, proof }: {
        contract: string;
        lockDuration: number;
        msg: Binary;
        proof?: LockTokensProof;
    }, fee_?: number | StdFee | 'auto', memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    approve: ({ expires, spender, tokenId }: {
        expires?: Expiration;
        spender: string;
        tokenId: string;
    }, fee_?: number | StdFee | 'auto', memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    revoke: ({ spender, tokenId }: {
        spender: string;
        tokenId: string;
    }, fee_?: number | StdFee | 'auto', memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    approveAll: ({ expires, operator }: {
        expires?: Expiration;
        operator: string;
    }, fee_?: number | StdFee | 'auto', memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    revokeAll: ({ operator }: {
        operator: string;
    }, fee_?: number | StdFee | 'auto', memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
}
export declare class HydroBaseClient extends HydroBaseQueryClient implements HydroBaseInterface {
    client: SigningCosmWasmClient;
    sender: string;
    contractAddress: string;
    constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string);
    lockTokens: ({ lockDuration, proof }: {
        lockDuration: number;
        proof?: LockTokensProof;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    refreshLockDuration: ({ lockDuration, lockIds }: {
        lockDuration: number;
        lockIds: number[];
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    unlockTokens: ({ lockIds }: {
        lockIds?: number[];
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    createProposal: ({ deploymentDuration, description, minimumAtomLiquidityRequest, roundId, title, trancheId }: {
        deploymentDuration: number;
        description: string;
        minimumAtomLiquidityRequest: Uint128;
        roundId?: number;
        title: string;
        trancheId: number;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    vote: ({ proposalsVotes, trancheId }: {
        proposalsVotes: ProposalToLockups[];
        trancheId: number;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    unvote: ({ lockIds, trancheId }: {
        lockIds: number[];
        trancheId: number;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    addAccountToWhitelist: ({ address }: {
        address: string;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    removeAccountFromWhitelist: ({ address }: {
        address: string;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    updateConfig: ({ activateAt, cw721CollectionInfo, knownUsersCap, maxDeploymentDuration, maxLockedTokens }: {
        activateAt: Timestamp;
        cw721CollectionInfo?: CollectionInfo;
        knownUsersCap?: number;
        maxDeploymentDuration?: number;
        maxLockedTokens?: number;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    deleteConfigs: ({ timestamps }: {
        timestamps: Timestamp[];
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    pause: (fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    addTranche: ({ tranche }: {
        tranche: TrancheInfo;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    editTranche: ({ trancheId, trancheMetadata, trancheName }: {
        trancheId: number;
        trancheMetadata?: string;
        trancheName?: string;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    createIcqsForValidators: ({ validators }: {
        validators: string[];
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    addICQManager: ({ address }: {
        address: string;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    removeICQManager: ({ address }: {
        address: string;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    withdrawICQFunds: ({ amount }: {
        amount: Uint128;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    addLiquidityDeployment: ({ deployedFunds, destinations, fundsBeforeDeployment, proposalId, remainingRounds, roundId, totalRounds, trancheId }: {
        deployedFunds: Coin[];
        destinations: string[];
        fundsBeforeDeployment: Coin[];
        proposalId: number;
        remainingRounds: number;
        roundId: number;
        totalRounds: number;
        trancheId: number;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    removeLiquidityDeployment: ({ proposalId, roundId, trancheId }: {
        proposalId: number;
        roundId: number;
        trancheId: number;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    updateTokenGroupRatio: ({ newRatio, oldRatio, tokenGroupId }: {
        newRatio: Decimal;
        oldRatio: Decimal;
        tokenGroupId: string;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    addTokenInfoProvider: ({ tokenInfoProvider }: {
        tokenInfoProvider: TokenInfoProviderInstantiateMsg;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    removeTokenInfoProvider: ({ providerId }: {
        providerId: string;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    setGatekeeper: ({ gatekeeperAddr }: {
        gatekeeperAddr?: string;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    transferNft: ({ recipient, tokenId }: {
        recipient: string;
        tokenId: string;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    sendNft: ({ contract, msg, tokenId }: {
        contract: string;
        msg: Binary;
        tokenId: string;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    lockTokensThenSendNft: ({ contract, lockDuration, msg, proof }: {
        contract: string;
        lockDuration: number;
        msg: Binary;
        proof?: LockTokensProof;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    approve: ({ expires, spender, tokenId }: {
        expires?: Expiration;
        spender: string;
        tokenId: string;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    revoke: ({ spender, tokenId }: {
        spender: string;
        tokenId: string;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    approveAll: ({ expires, operator }: {
        expires?: Expiration;
        operator: string;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
    revokeAll: ({ operator }: {
        operator: string;
    }, fee_?: number | StdFee | "auto", memo_?: string, funds_?: Coin[]) => Promise<ExecuteResult>;
}
//# sourceMappingURL=HydroBase.client.d.ts.map