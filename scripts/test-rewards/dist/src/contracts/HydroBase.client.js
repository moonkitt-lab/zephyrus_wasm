"use strict";
/**
 * This file was automatically generated by @cosmwasm/ts-codegen@1.12.1.
 * DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
 * and run the @cosmwasm/ts-codegen generate command to regenerate this file.
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.HydroBaseClient = exports.HydroBaseQueryClient = void 0;
class HydroBaseQueryClient {
    constructor(client, contractAddress) {
        this.constants = async () => {
            return this.client.queryContractSmart(this.contractAddress, {
                constants: {}
            });
        };
        this.tokenInfoProviders = async () => {
            return this.client.queryContractSmart(this.contractAddress, {
                token_info_providers: {}
            });
        };
        this.gatekeeper = async () => {
            return this.client.queryContractSmart(this.contractAddress, {
                gatekeeper: {}
            });
        };
        this.tranches = async () => {
            return this.client.queryContractSmart(this.contractAddress, {
                tranches: {}
            });
        };
        this.allUserLockups = async ({ address, limit, startFrom }) => {
            return this.client.queryContractSmart(this.contractAddress, {
                all_user_lockups: {
                    address,
                    limit,
                    start_from: startFrom
                }
            });
        };
        this.specificUserLockups = async ({ address, lockIds }) => {
            return this.client.queryContractSmart(this.contractAddress, {
                specific_user_lockups: {
                    address,
                    lock_ids: lockIds
                }
            });
        };
        this.allUserLockupsWithTrancheInfos = async ({ address, limit, startFrom }) => {
            return this.client.queryContractSmart(this.contractAddress, {
                all_user_lockups_with_tranche_infos: {
                    address,
                    limit,
                    start_from: startFrom
                }
            });
        };
        this.specificUserLockupsWithTrancheInfos = async ({ address, lockIds }) => {
            return this.client.queryContractSmart(this.contractAddress, {
                specific_user_lockups_with_tranche_infos: {
                    address,
                    lock_ids: lockIds
                }
            });
        };
        this.expiredUserLockups = async ({ address, limit, startFrom }) => {
            return this.client.queryContractSmart(this.contractAddress, {
                expired_user_lockups: {
                    address,
                    limit,
                    start_from: startFrom
                }
            });
        };
        this.userVotingPower = async ({ address }) => {
            return this.client.queryContractSmart(this.contractAddress, {
                user_voting_power: {
                    address
                }
            });
        };
        this.userVotes = async ({ address, roundId, trancheId }) => {
            return this.client.queryContractSmart(this.contractAddress, {
                user_votes: {
                    address,
                    round_id: roundId,
                    tranche_id: trancheId
                }
            });
        };
        this.userVotedLocks = async ({ proposalId, roundId, trancheId, userAddress }) => {
            return this.client.queryContractSmart(this.contractAddress, {
                user_voted_locks: {
                    proposal_id: proposalId,
                    round_id: roundId,
                    tranche_id: trancheId,
                    user_address: userAddress
                }
            });
        };
        this.lockVotesHistory = async ({ lockId, startFromRoundId, stopAtRoundId, trancheId }) => {
            return this.client.queryContractSmart(this.contractAddress, {
                lock_votes_history: {
                    lock_id: lockId,
                    start_from_round_id: startFromRoundId,
                    stop_at_round_id: stopAtRoundId,
                    tranche_id: trancheId
                }
            });
        };
        this.allVotes = async ({ limit, startFrom }) => {
            return this.client.queryContractSmart(this.contractAddress, {
                all_votes: {
                    limit,
                    start_from: startFrom
                }
            });
        };
        this.allVotesRoundTranche = async ({ limit, roundId, startFrom, trancheId }) => {
            return this.client.queryContractSmart(this.contractAddress, {
                all_votes_round_tranche: {
                    limit,
                    round_id: roundId,
                    start_from: startFrom,
                    tranche_id: trancheId
                }
            });
        };
        this.currentRound = async () => {
            return this.client.queryContractSmart(this.contractAddress, {
                current_round: {}
            });
        };
        this.roundEnd = async ({ roundId }) => {
            return this.client.queryContractSmart(this.contractAddress, {
                round_end: {
                    round_id: roundId
                }
            });
        };
        this.roundTotalVotingPower = async ({ roundId }) => {
            return this.client.queryContractSmart(this.contractAddress, {
                round_total_voting_power: {
                    round_id: roundId
                }
            });
        };
        this.roundProposals = async ({ limit, roundId, startFrom, trancheId }) => {
            return this.client.queryContractSmart(this.contractAddress, {
                round_proposals: {
                    limit,
                    round_id: roundId,
                    start_from: startFrom,
                    tranche_id: trancheId
                }
            });
        };
        this.proposal = async ({ proposalId, roundId, trancheId }) => {
            return this.client.queryContractSmart(this.contractAddress, {
                proposal: {
                    proposal_id: proposalId,
                    round_id: roundId,
                    tranche_id: trancheId
                }
            });
        };
        this.topNProposals = async ({ numberOfProposals, roundId, trancheId }) => {
            return this.client.queryContractSmart(this.contractAddress, {
                top_n_proposals: {
                    number_of_proposals: numberOfProposals,
                    round_id: roundId,
                    tranche_id: trancheId
                }
            });
        };
        this.whitelist = async () => {
            return this.client.queryContractSmart(this.contractAddress, {
                whitelist: {}
            });
        };
        this.whitelistAdmins = async () => {
            return this.client.queryContractSmart(this.contractAddress, {
                whitelist_admins: {}
            });
        };
        this.iCQManagers = async () => {
            return this.client.queryContractSmart(this.contractAddress, {
                i_c_q_managers: {}
            });
        };
        this.totalLockedTokens = async () => {
            return this.client.queryContractSmart(this.contractAddress, {
                total_locked_tokens: {}
            });
        };
        this.registeredValidatorQueries = async () => {
            return this.client.queryContractSmart(this.contractAddress, {
                registered_validator_queries: {}
            });
        };
        this.canLockDenom = async ({ tokenDenom }) => {
            return this.client.queryContractSmart(this.contractAddress, {
                can_lock_denom: {
                    token_denom: tokenDenom
                }
            });
        };
        this.liquidityDeployment = async ({ proposalId, roundId, trancheId }) => {
            return this.client.queryContractSmart(this.contractAddress, {
                liquidity_deployment: {
                    proposal_id: proposalId,
                    round_id: roundId,
                    tranche_id: trancheId
                }
            });
        };
        this.roundTrancheLiquidityDeployments = async ({ limit, roundId, startFrom, trancheId }) => {
            return this.client.queryContractSmart(this.contractAddress, {
                round_tranche_liquidity_deployments: {
                    limit,
                    round_id: roundId,
                    start_from: startFrom,
                    tranche_id: trancheId
                }
            });
        };
        this.totalPowerAtHeight = async ({ height }) => {
            return this.client.queryContractSmart(this.contractAddress, {
                total_power_at_height: {
                    height
                }
            });
        };
        this.votingPowerAtHeight = async ({ address, height }) => {
            return this.client.queryContractSmart(this.contractAddress, {
                voting_power_at_height: {
                    address,
                    height
                }
            });
        };
        this.ownerOf = async ({ includeExpired, tokenId }) => {
            return this.client.queryContractSmart(this.contractAddress, {
                owner_of: {
                    include_expired: includeExpired,
                    token_id: tokenId
                }
            });
        };
        this.approval = async ({ includeExpired, spender, tokenId }) => {
            return this.client.queryContractSmart(this.contractAddress, {
                approval: {
                    include_expired: includeExpired,
                    spender,
                    token_id: tokenId
                }
            });
        };
        this.approvals = async ({ includeExpired, tokenId }) => {
            return this.client.queryContractSmart(this.contractAddress, {
                approvals: {
                    include_expired: includeExpired,
                    token_id: tokenId
                }
            });
        };
        this.allOperators = async ({ includeExpired, limit, owner, startAfter }) => {
            return this.client.queryContractSmart(this.contractAddress, {
                all_operators: {
                    include_expired: includeExpired,
                    limit,
                    owner,
                    start_after: startAfter
                }
            });
        };
        this.numTokens = async () => {
            return this.client.queryContractSmart(this.contractAddress, {
                num_tokens: {}
            });
        };
        this.collectionInfo = async () => {
            return this.client.queryContractSmart(this.contractAddress, {
                collection_info: {}
            });
        };
        this.nftInfo = async ({ tokenId }) => {
            return this.client.queryContractSmart(this.contractAddress, {
                nft_info: {
                    token_id: tokenId
                }
            });
        };
        this.allNftInfo = async ({ includeExpired, tokenId }) => {
            return this.client.queryContractSmart(this.contractAddress, {
                all_nft_info: {
                    include_expired: includeExpired,
                    token_id: tokenId
                }
            });
        };
        this.tokens = async ({ limit, owner, startAfter }) => {
            return this.client.queryContractSmart(this.contractAddress, {
                tokens: {
                    limit,
                    owner,
                    start_after: startAfter
                }
            });
        };
        this.allTokens = async ({ limit, startAfter }) => {
            return this.client.queryContractSmart(this.contractAddress, {
                all_tokens: {
                    limit,
                    start_after: startAfter
                }
            });
        };
        this.lockupsShares = async ({ lockIds }) => {
            return this.client.queryContractSmart(this.contractAddress, {
                lockups_shares: {
                    lock_ids: lockIds
                }
            });
        };
        this.client = client;
        this.contractAddress = contractAddress;
        this.constants = this.constants.bind(this);
        this.tokenInfoProviders = this.tokenInfoProviders.bind(this);
        this.gatekeeper = this.gatekeeper.bind(this);
        this.tranches = this.tranches.bind(this);
        this.allUserLockups = this.allUserLockups.bind(this);
        this.specificUserLockups = this.specificUserLockups.bind(this);
        this.allUserLockupsWithTrancheInfos = this.allUserLockupsWithTrancheInfos.bind(this);
        this.specificUserLockupsWithTrancheInfos = this.specificUserLockupsWithTrancheInfos.bind(this);
        this.expiredUserLockups = this.expiredUserLockups.bind(this);
        this.userVotingPower = this.userVotingPower.bind(this);
        this.userVotes = this.userVotes.bind(this);
        this.userVotedLocks = this.userVotedLocks.bind(this);
        this.lockVotesHistory = this.lockVotesHistory.bind(this);
        this.allVotes = this.allVotes.bind(this);
        this.allVotesRoundTranche = this.allVotesRoundTranche.bind(this);
        this.currentRound = this.currentRound.bind(this);
        this.roundEnd = this.roundEnd.bind(this);
        this.roundTotalVotingPower = this.roundTotalVotingPower.bind(this);
        this.roundProposals = this.roundProposals.bind(this);
        this.proposal = this.proposal.bind(this);
        this.topNProposals = this.topNProposals.bind(this);
        this.whitelist = this.whitelist.bind(this);
        this.whitelistAdmins = this.whitelistAdmins.bind(this);
        this.iCQManagers = this.iCQManagers.bind(this);
        this.totalLockedTokens = this.totalLockedTokens.bind(this);
        this.registeredValidatorQueries = this.registeredValidatorQueries.bind(this);
        this.canLockDenom = this.canLockDenom.bind(this);
        this.liquidityDeployment = this.liquidityDeployment.bind(this);
        this.roundTrancheLiquidityDeployments = this.roundTrancheLiquidityDeployments.bind(this);
        this.totalPowerAtHeight = this.totalPowerAtHeight.bind(this);
        this.votingPowerAtHeight = this.votingPowerAtHeight.bind(this);
        this.ownerOf = this.ownerOf.bind(this);
        this.approval = this.approval.bind(this);
        this.approvals = this.approvals.bind(this);
        this.allOperators = this.allOperators.bind(this);
        this.numTokens = this.numTokens.bind(this);
        this.collectionInfo = this.collectionInfo.bind(this);
        this.nftInfo = this.nftInfo.bind(this);
        this.allNftInfo = this.allNftInfo.bind(this);
        this.tokens = this.tokens.bind(this);
        this.allTokens = this.allTokens.bind(this);
        this.lockupsShares = this.lockupsShares.bind(this);
    }
}
exports.HydroBaseQueryClient = HydroBaseQueryClient;
class HydroBaseClient extends HydroBaseQueryClient {
    constructor(client, sender, contractAddress) {
        super(client, contractAddress);
        this.lockTokens = async ({ lockDuration, proof }, fee_ = 'auto', memo_, funds_) => {
            return await this.client.execute(this.sender, this.contractAddress, {
                lock_tokens: {
                    lock_duration: lockDuration,
                    proof
                }
            }, fee_, memo_, funds_);
        };
        this.refreshLockDuration = async ({ lockDuration, lockIds }, fee_ = 'auto', memo_, funds_) => {
            return await this.client.execute(this.sender, this.contractAddress, {
                refresh_lock_duration: {
                    lock_duration: lockDuration,
                    lock_ids: lockIds
                }
            }, fee_, memo_, funds_);
        };
        this.unlockTokens = async ({ lockIds }, fee_ = 'auto', memo_, funds_) => {
            return await this.client.execute(this.sender, this.contractAddress, {
                unlock_tokens: {
                    lock_ids: lockIds
                }
            }, fee_, memo_, funds_);
        };
        this.createProposal = async ({ deploymentDuration, description, minimumAtomLiquidityRequest, roundId, title, trancheId }, fee_ = 'auto', memo_, funds_) => {
            return await this.client.execute(this.sender, this.contractAddress, {
                create_proposal: {
                    deployment_duration: deploymentDuration,
                    description,
                    minimum_atom_liquidity_request: minimumAtomLiquidityRequest,
                    round_id: roundId,
                    title,
                    tranche_id: trancheId
                }
            }, fee_, memo_, funds_);
        };
        this.vote = async ({ proposalsVotes, trancheId }, fee_ = 'auto', memo_, funds_) => {
            return await this.client.execute(this.sender, this.contractAddress, {
                vote: {
                    proposals_votes: proposalsVotes,
                    tranche_id: trancheId
                }
            }, fee_, memo_, funds_);
        };
        this.unvote = async ({ lockIds, trancheId }, fee_ = 'auto', memo_, funds_) => {
            return await this.client.execute(this.sender, this.contractAddress, {
                unvote: {
                    lock_ids: lockIds,
                    tranche_id: trancheId
                }
            }, fee_, memo_, funds_);
        };
        this.addAccountToWhitelist = async ({ address }, fee_ = 'auto', memo_, funds_) => {
            return await this.client.execute(this.sender, this.contractAddress, {
                add_account_to_whitelist: {
                    address
                }
            }, fee_, memo_, funds_);
        };
        this.removeAccountFromWhitelist = async ({ address }, fee_ = 'auto', memo_, funds_) => {
            return await this.client.execute(this.sender, this.contractAddress, {
                remove_account_from_whitelist: {
                    address
                }
            }, fee_, memo_, funds_);
        };
        this.updateConfig = async ({ activateAt, cw721CollectionInfo, knownUsersCap, maxDeploymentDuration, maxLockedTokens }, fee_ = 'auto', memo_, funds_) => {
            return await this.client.execute(this.sender, this.contractAddress, {
                update_config: {
                    activate_at: activateAt,
                    cw721_collection_info: cw721CollectionInfo,
                    known_users_cap: knownUsersCap,
                    max_deployment_duration: maxDeploymentDuration,
                    max_locked_tokens: maxLockedTokens
                }
            }, fee_, memo_, funds_);
        };
        this.deleteConfigs = async ({ timestamps }, fee_ = 'auto', memo_, funds_) => {
            return await this.client.execute(this.sender, this.contractAddress, {
                delete_configs: {
                    timestamps
                }
            }, fee_, memo_, funds_);
        };
        this.pause = async (fee_ = 'auto', memo_, funds_) => {
            return await this.client.execute(this.sender, this.contractAddress, {
                pause: {}
            }, fee_, memo_, funds_);
        };
        this.addTranche = async ({ tranche }, fee_ = 'auto', memo_, funds_) => {
            return await this.client.execute(this.sender, this.contractAddress, {
                add_tranche: {
                    tranche
                }
            }, fee_, memo_, funds_);
        };
        this.editTranche = async ({ trancheId, trancheMetadata, trancheName }, fee_ = 'auto', memo_, funds_) => {
            return await this.client.execute(this.sender, this.contractAddress, {
                edit_tranche: {
                    tranche_id: trancheId,
                    tranche_metadata: trancheMetadata,
                    tranche_name: trancheName
                }
            }, fee_, memo_, funds_);
        };
        this.createIcqsForValidators = async ({ validators }, fee_ = 'auto', memo_, funds_) => {
            return await this.client.execute(this.sender, this.contractAddress, {
                create_icqs_for_validators: {
                    validators
                }
            }, fee_, memo_, funds_);
        };
        this.addICQManager = async ({ address }, fee_ = 'auto', memo_, funds_) => {
            return await this.client.execute(this.sender, this.contractAddress, {
                add_i_c_q_manager: {
                    address
                }
            }, fee_, memo_, funds_);
        };
        this.removeICQManager = async ({ address }, fee_ = 'auto', memo_, funds_) => {
            return await this.client.execute(this.sender, this.contractAddress, {
                remove_i_c_q_manager: {
                    address
                }
            }, fee_, memo_, funds_);
        };
        this.withdrawICQFunds = async ({ amount }, fee_ = 'auto', memo_, funds_) => {
            return await this.client.execute(this.sender, this.contractAddress, {
                withdraw_i_c_q_funds: {
                    amount
                }
            }, fee_, memo_, funds_);
        };
        this.addLiquidityDeployment = async ({ deployedFunds, destinations, fundsBeforeDeployment, proposalId, remainingRounds, roundId, totalRounds, trancheId }, fee_ = 'auto', memo_, funds_) => {
            return await this.client.execute(this.sender, this.contractAddress, {
                add_liquidity_deployment: {
                    deployed_funds: deployedFunds,
                    destinations,
                    funds_before_deployment: fundsBeforeDeployment,
                    proposal_id: proposalId,
                    remaining_rounds: remainingRounds,
                    round_id: roundId,
                    total_rounds: totalRounds,
                    tranche_id: trancheId
                }
            }, fee_, memo_, funds_);
        };
        this.removeLiquidityDeployment = async ({ proposalId, roundId, trancheId }, fee_ = 'auto', memo_, funds_) => {
            return await this.client.execute(this.sender, this.contractAddress, {
                remove_liquidity_deployment: {
                    proposal_id: proposalId,
                    round_id: roundId,
                    tranche_id: trancheId
                }
            }, fee_, memo_, funds_);
        };
        this.updateTokenGroupRatio = async ({ newRatio, oldRatio, tokenGroupId }, fee_ = 'auto', memo_, funds_) => {
            return await this.client.execute(this.sender, this.contractAddress, {
                update_token_group_ratio: {
                    new_ratio: newRatio,
                    old_ratio: oldRatio,
                    token_group_id: tokenGroupId
                }
            }, fee_, memo_, funds_);
        };
        this.addTokenInfoProvider = async ({ tokenInfoProvider }, fee_ = 'auto', memo_, funds_) => {
            return await this.client.execute(this.sender, this.contractAddress, {
                add_token_info_provider: {
                    token_info_provider: tokenInfoProvider
                }
            }, fee_, memo_, funds_);
        };
        this.removeTokenInfoProvider = async ({ providerId }, fee_ = 'auto', memo_, funds_) => {
            return await this.client.execute(this.sender, this.contractAddress, {
                remove_token_info_provider: {
                    provider_id: providerId
                }
            }, fee_, memo_, funds_);
        };
        this.setGatekeeper = async ({ gatekeeperAddr }, fee_ = 'auto', memo_, funds_) => {
            return await this.client.execute(this.sender, this.contractAddress, {
                set_gatekeeper: {
                    gatekeeper_addr: gatekeeperAddr
                }
            }, fee_, memo_, funds_);
        };
        this.transferNft = async ({ recipient, tokenId }, fee_ = 'auto', memo_, funds_) => {
            return await this.client.execute(this.sender, this.contractAddress, {
                transfer_nft: {
                    recipient,
                    token_id: tokenId
                }
            }, fee_, memo_, funds_);
        };
        this.sendNft = async ({ contract, msg, tokenId }, fee_ = 'auto', memo_, funds_) => {
            return await this.client.execute(this.sender, this.contractAddress, {
                send_nft: {
                    contract,
                    msg,
                    token_id: tokenId
                }
            }, fee_, memo_, funds_);
        };
        this.lockTokensThenSendNft = async ({ contract, lockDuration, msg, proof }, fee_ = 'auto', memo_, funds_) => {
            return await this.client.execute(this.sender, this.contractAddress, {
                lock_tokens_then_send_nft: {
                    contract,
                    lock_duration: lockDuration,
                    msg,
                    proof
                }
            }, fee_, memo_, funds_);
        };
        this.approve = async ({ expires, spender, tokenId }, fee_ = 'auto', memo_, funds_) => {
            return await this.client.execute(this.sender, this.contractAddress, {
                approve: {
                    expires,
                    spender,
                    token_id: tokenId
                }
            }, fee_, memo_, funds_);
        };
        this.revoke = async ({ spender, tokenId }, fee_ = 'auto', memo_, funds_) => {
            return await this.client.execute(this.sender, this.contractAddress, {
                revoke: {
                    spender,
                    token_id: tokenId
                }
            }, fee_, memo_, funds_);
        };
        this.approveAll = async ({ expires, operator }, fee_ = 'auto', memo_, funds_) => {
            return await this.client.execute(this.sender, this.contractAddress, {
                approve_all: {
                    expires,
                    operator
                }
            }, fee_, memo_, funds_);
        };
        this.revokeAll = async ({ operator }, fee_ = 'auto', memo_, funds_) => {
            return await this.client.execute(this.sender, this.contractAddress, {
                revoke_all: {
                    operator
                }
            }, fee_, memo_, funds_);
        };
        this.client = client;
        this.sender = sender;
        this.contractAddress = contractAddress;
        this.lockTokens = this.lockTokens.bind(this);
        this.refreshLockDuration = this.refreshLockDuration.bind(this);
        this.unlockTokens = this.unlockTokens.bind(this);
        this.createProposal = this.createProposal.bind(this);
        this.vote = this.vote.bind(this);
        this.unvote = this.unvote.bind(this);
        this.addAccountToWhitelist = this.addAccountToWhitelist.bind(this);
        this.removeAccountFromWhitelist = this.removeAccountFromWhitelist.bind(this);
        this.updateConfig = this.updateConfig.bind(this);
        this.deleteConfigs = this.deleteConfigs.bind(this);
        this.pause = this.pause.bind(this);
        this.addTranche = this.addTranche.bind(this);
        this.editTranche = this.editTranche.bind(this);
        this.createIcqsForValidators = this.createIcqsForValidators.bind(this);
        this.addICQManager = this.addICQManager.bind(this);
        this.removeICQManager = this.removeICQManager.bind(this);
        this.withdrawICQFunds = this.withdrawICQFunds.bind(this);
        this.addLiquidityDeployment = this.addLiquidityDeployment.bind(this);
        this.removeLiquidityDeployment = this.removeLiquidityDeployment.bind(this);
        this.updateTokenGroupRatio = this.updateTokenGroupRatio.bind(this);
        this.addTokenInfoProvider = this.addTokenInfoProvider.bind(this);
        this.removeTokenInfoProvider = this.removeTokenInfoProvider.bind(this);
        this.setGatekeeper = this.setGatekeeper.bind(this);
        this.transferNft = this.transferNft.bind(this);
        this.sendNft = this.sendNft.bind(this);
        this.lockTokensThenSendNft = this.lockTokensThenSendNft.bind(this);
        this.approve = this.approve.bind(this);
        this.revoke = this.revoke.bind(this);
        this.approveAll = this.approveAll.bind(this);
        this.revokeAll = this.revokeAll.bind(this);
    }
}
exports.HydroBaseClient = HydroBaseClient;
//# sourceMappingURL=HydroBase.client.js.map