/**
* This file was automatically generated by @cosmwasm/ts-codegen@1.11.1.
* DO NOT MODIFY IT BY HAND. Instead, modify the source JSONSchema file,
* and run the @cosmwasm/ts-codegen generate command to regenerate this file.
*/
import { CosmWasmClient, SigningCosmWasmClient } from "@cosmjs/cosmwasm-stargate";
import type { ExecuteResult } from "@cosmjs/cosmwasm-stargate";
import type { StdFee } from "@cosmjs/amino";
import type { Decimal, Binary, VesselsToHarbor, ConstantsResponse, VesselsResponse, VesselHarborResponse, VesselsRewardsResponse, Coin, VotingPowerResponse } from "./ZephyrusMain.types";
export interface ZephyrusMainReadOnlyInterface {
    contractAddress: string;
    votingPower: () => Promise<VotingPowerResponse>;
    vesselsByOwner: ({ limit, owner, startIndex }: {
        limit?: number;
        owner: string;
        startIndex?: number;
    }) => Promise<VesselsResponse>;
    vesselsByHydromancer: ({ hydromancerAddr, limit, startIndex }: {
        hydromancerAddr: string;
        limit?: number;
        startIndex?: number;
    }) => Promise<VesselsResponse>;
    constants: () => Promise<ConstantsResponse>;
    vesselsHarbor: ({ lockIds, roundId, trancheId }: {
        lockIds: number[];
        roundId: number;
        trancheId: number;
    }) => Promise<VesselHarborResponse>;
    vesselsRewards: ({ roundId, trancheId, userAddress, vesselIds }: {
        roundId: number;
        trancheId: number;
        userAddress: string;
        vesselIds: number[];
    }) => Promise<VesselsRewardsResponse>;
}
export declare class ZephyrusMainQueryClient implements ZephyrusMainReadOnlyInterface {
    client: CosmWasmClient;
    contractAddress: string;
    constructor(client: CosmWasmClient, contractAddress: string);
    votingPower: () => Promise<VotingPowerResponse>;
    vesselsByOwner: ({ limit, owner, startIndex }: {
        limit?: number;
        owner: string;
        startIndex?: number;
    }) => Promise<VesselsResponse>;
    vesselsByHydromancer: ({ hydromancerAddr, limit, startIndex }: {
        hydromancerAddr: string;
        limit?: number;
        startIndex?: number;
    }) => Promise<VesselsResponse>;
    constants: () => Promise<ConstantsResponse>;
    vesselsHarbor: ({ lockIds, roundId, trancheId }: {
        lockIds: number[];
        roundId: number;
        trancheId: number;
    }) => Promise<VesselHarborResponse>;
    vesselsRewards: ({ roundId, trancheId, userAddress, vesselIds }: {
        roundId: number;
        trancheId: number;
        userAddress: string;
        vesselIds: number[];
    }) => Promise<VesselsRewardsResponse>;
}
export interface ZephyrusMainInterface extends ZephyrusMainReadOnlyInterface {
    contractAddress: string;
    sender: string;
    takeControl: ({ vesselIds }: {
        vesselIds: number[];
    }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
    unvote: ({ trancheId, vesselIds }: {
        trancheId: number;
        vesselIds: number[];
    }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
    updateVesselsClass: ({ hydroLockDuration, hydroLockIds }: {
        hydroLockDuration: number;
        hydroLockIds: number[];
    }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
    autoMaintain: ({ limit, startFromVesselId }: {
        limit?: number;
        startFromVesselId?: number;
    }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
    modifyAutoMaintenance: ({ autoMaintenance, hydroLockIds }: {
        autoMaintenance: boolean;
        hydroLockIds: number[];
    }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
    pauseContract: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
    unpauseContract: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
    decommissionVessels: ({ hydroLockIds }: {
        hydroLockIds: number[];
    }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
    hydromancerVote: ({ trancheId, vesselsHarbors }: {
        trancheId: number;
        vesselsHarbors: VesselsToHarbor[];
    }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
    userVote: ({ trancheId, vesselsHarbors }: {
        trancheId: number;
        vesselsHarbors: VesselsToHarbor[];
    }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
    receiveNft: ({ msg, sender, tokenId }: {
        msg: Binary;
        sender: string;
        tokenId: string;
    }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
    changeHydromancer: ({ hydroLockIds, hydromancerId, trancheId }: {
        hydroLockIds: number[];
        hydromancerId: number;
        trancheId: number;
    }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
    claim: ({ roundId, trancheId, vesselIds }: {
        roundId: number;
        trancheId: number;
        vesselIds: number[];
    }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
    updateCommissionRate: ({ newCommissionRate }: {
        newCommissionRate: Decimal;
    }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
    updateCommissionRecipient: ({ newCommissionRecipient }: {
        newCommissionRecipient: string;
    }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
export declare class ZephyrusMainClient extends ZephyrusMainQueryClient implements ZephyrusMainInterface {
    client: SigningCosmWasmClient;
    sender: string;
    contractAddress: string;
    constructor(client: SigningCosmWasmClient, sender: string, contractAddress: string);
    takeControl: ({ vesselIds }: {
        vesselIds: number[];
    }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
    unvote: ({ trancheId, vesselIds }: {
        trancheId: number;
        vesselIds: number[];
    }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
    updateVesselsClass: ({ hydroLockDuration, hydroLockIds }: {
        hydroLockDuration: number;
        hydroLockIds: number[];
    }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
    autoMaintain: ({ limit, startFromVesselId }: {
        limit?: number;
        startFromVesselId?: number;
    }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
    modifyAutoMaintenance: ({ autoMaintenance, hydroLockIds }: {
        autoMaintenance: boolean;
        hydroLockIds: number[];
    }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
    pauseContract: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
    unpauseContract: (fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
    decommissionVessels: ({ hydroLockIds }: {
        hydroLockIds: number[];
    }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
    hydromancerVote: ({ trancheId, vesselsHarbors }: {
        trancheId: number;
        vesselsHarbors: VesselsToHarbor[];
    }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
    userVote: ({ trancheId, vesselsHarbors }: {
        trancheId: number;
        vesselsHarbors: VesselsToHarbor[];
    }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
    receiveNft: ({ msg, sender, tokenId }: {
        msg: Binary;
        sender: string;
        tokenId: string;
    }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
    changeHydromancer: ({ hydroLockIds, hydromancerId, trancheId }: {
        hydroLockIds: number[];
        hydromancerId: number;
        trancheId: number;
    }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
    claim: ({ roundId, trancheId, vesselIds }: {
        roundId: number;
        trancheId: number;
        vesselIds: number[];
    }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
    updateCommissionRate: ({ newCommissionRate }: {
        newCommissionRate: Decimal;
    }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
    updateCommissionRecipient: ({ newCommissionRecipient }: {
        newCommissionRecipient: string;
    }, fee?: number | StdFee | "auto", memo?: string, _funds?: Coin[]) => Promise<ExecuteResult>;
}
//# sourceMappingURL=ZephyrusMain.client.d.ts.map